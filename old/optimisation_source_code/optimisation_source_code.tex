\chapter{Optimisation Source Code}




\begin{lstlisting}[style=sFortran,caption={Add two numbers function}]
!=================================================================================================
!
! LMA algorithm
! Levenberg, K.: 1944, Quarterly of Applied Mathematics 2, 164:
!    Dampened Newton Gauss Algorithm
! Marquardt, D.: 1963, Journal of the Society for Industrial and Applied Mathematics 11(2), 431:
!    Introduction of Lambda (Marquardt Parameter)
! R. Fletcher 1971, A modified Marquardt Subroutine for Non-linear Least Squares
!    Starting Lambda and lower lambda cutoff (where it is replaced by 0)
! M. Transtrum, J. Sethna 2012, Improvements to the Levenberg-Marquardt algorithm for nonlinear
! least-squares minimization:
!    Delayed gratification scheme for varying lambda
! Jens Jessen-Hansen 2011, Levenberg-Marquardts algorithm Project in Numerical Methods:
!    Independent/Diagonal covariance matrix for weighting
! Parameter limits implemented
! Finite difference method used to calculate J
!
!=================================================================================================

! Note:
! f2py doesn't work well with external or interface defined functions
! therefore the function is picked using an integer and all functions
! available exist in another file
!

FUNCTION LMA&
(F, parametersIn, points) &
RESULT (parametersOut)
! LMA Function
IMPLICIT NONE
! Vars:  In
INTEGER :: F
REAL(8), Dimension(:) :: parametersIn
REAL(8), Dimension(:,:) :: points
! Vars:  Out
REAL(8), Dimension(1:size(parametersIn,1)) :: parametersOut
! Parameters
REAL(8), Dimension(1:size(parametersIn,1), 1:2) :: limits
LOGICAL :: weighting
REAL(8) :: p_conv_threshold
REAL(8) :: rss_threshold
INTEGER :: lma_loops
INTEGER :: lambda_loops
REAL(8) :: difference_factor

weighting = .True.
p_conv_threshold = 1.0D-20
rss_threshold = 1.0D-20
lma_loops = 20
lambda_loops = 100
difference_factor = 1.0D-9
limits = 0.0D0

! Call subroutine
CALL LMA_Sub (&
F, parametersIn, points, &
limits, &
weighting, p_conv_threshold, rss_threshold, &
lma_loops, lambda_loops, difference_factor, &
parametersOut)
END FUNCTION LMA


FUNCTION LMA_L&
(F, parametersIn, points, limits) &
RESULT (parametersOut)
! LMA Function
IMPLICIT NONE
! Vars:  In
INTEGER :: F
REAL(8), Dimension(:) :: parametersIn
REAL(8), Dimension(:,:) :: points
REAL(8), Dimension(:,:) :: limits
! Vars:  Out
REAL(8), Dimension(1:size(parametersIn,1)) :: parametersOut
! Parameters
LOGICAL :: weighting
REAL(8) :: p_conv_threshold
REAL(8) :: rss_threshold
INTEGER :: lma_loops
INTEGER :: lambda_loops
REAL(8) :: difference_factor

weighting = .True.
p_conv_threshold = 1.0D-20
rss_threshold = 1.0D-20
lma_loops = 100
lambda_loops = 100
difference_factor = 1.0D-9

! Call subroutine
CALL LMA_Sub (&
F, parametersIn, points, &
limits, &
weighting, p_conv_threshold, rss_threshold, &
lma_loops, lambda_loops, difference_factor, &
parametersOut)
END FUNCTION LMA_L


FUNCTION LMA_Full&
(F, parametersIn, points, &
limits, &
weighting, p_conv_threshold, rss_threshold, &
lma_loops, lambda_loops, difference_factor) &
RESULT (parametersOut)
! LMA Function
IMPLICIT NONE
! Vars:  In
INTEGER :: F
REAL(8), Dimension(:) :: parametersIn
REAL(8), Dimension(:,:) :: points
REAL(8), Dimension(:,:) :: limits
LOGICAL :: weighting
REAL(8) :: p_conv_threshold
REAL(8) :: rss_threshold
INTEGER :: lma_loops
INTEGER :: lambda_loops
REAL(8) :: difference_factor
! Vars:  Out
REAL(8), Dimension(1:size(parametersIn,1)) :: parametersOut
! Call subroutine
CALL LMA_Sub (&
F, parametersIn, points, &
limits, &
weighting, p_conv_threshold, rss_threshold, &
lma_loops, lambda_loops, difference_factor, &
parametersOut)
END FUNCTION LMA_Full


SUBROUTINE LMA_Sub (&
F, parametersIn, points, &
limits, &
weighting, p_conv_threshold, rss_threshold, &
lma_loops, lambda_loops, difference_factor, &
parametersOut)

IMPLICIT NONE  !Force declaration of all variables
! Vars:  In/Out
INTEGER, INTENT(IN) :: F
REAL(8), INTENT(IN), Dimension(:) :: parametersIn
REAL(8), INTENT(IN), Dimension(:,:) :: points
REAL(8), Dimension(:,:) :: limits
LOGICAL, INTENT(IN) :: weighting
REAL(8) :: p_conv_threshold
REAL(8) :: rss_threshold
INTEGER :: lma_loops
INTEGER :: lambda_loops
REAL(8) :: difference_factor
REAL(8), Dimension(:) :: parametersOut
! Vars:  Private variables
INTEGER :: i, n, k
REAL(8), Dimension(1:size(parametersIn,1)) :: parameters, parametersT, parametersL
REAL(8), Dimension(1:size(points,1),1:size(parametersIn,1)) :: J
REAL(8), Dimension(1:size(points,1)) :: R
REAL(8) :: x, y, fx, fxP, dVal, dValFactor
REAL(8) :: lambda, lambdaCutoff
REAL(8) :: rss, p_conv_value
LOGICAL :: converged
LOGICAL :: run_lma_loop, run_lambda_loop

! Init vars
parameters = parametersIn
converged = .false.

n = 1
run_lma_loop = .True.
Do While((n .LE. 50) .AND. (run_lma_loop .EQV. .True.))  ! maximum 50 loops
  Call LMA_Make_J(F, parameters, points, difference_factor, J, R, rss)
! Starting lambda
  If(n.eq.1)Then
    lambdaCutoff = LMA_Lambda(J)
    lambda = lambdaCutoff
  End If

! Start loop - keep increasing lambda if not an improvement
  k = 1
  run_lambda_loop = .True.
  Do While((k .LE. 100) .AND. (run_lambda_loop .EQV. .True.)) ! max 100
    Call LMA_Loop(F, parameters, points, limits, weighting, J, R, rss, lambda, lambdaCutoff, &
    p_conv_threshold, p_conv_value, run_lambda_loop)
    k = k + 1
  End Do
  If((rss .LE. rss_threshold) .OR. (p_conv_value .LE. p_conv_threshold))Then
    run_lma_loop = .False.
  End If
  n = n + 1
End Do
parametersOut = parameters
END SUBROUTINE LMA_Sub


SUBROUTINE LMA_Make_J(F, parameters, points, difference_factor, J, R, rss)
! Makes J matrix finite difference
! R matrix
INTEGER :: F
REAL(8), Dimension(:) :: parameters
REAL(8), Dimension(:,:) :: points
REAL(8) :: difference_factor
REAL(8), INTENT(OUT), Dimension(1:size(points,1),1:size(parameters,1)) :: J
REAL(8), INTENT(OUT), Dimension(1:size(points,1)) :: R
REAL(8), INTENT(OUT) :: rss

INTEGER :: i, k
REAL(8) :: fx, fxP, finite_difference
REAL(8), Dimension(1:size(parameters,1)) :: parameters_perturbed

rss = 0.0D0
Do i=1,size(points,1)
  ! Calculated fx
  fx = LMA_F(F, parameters, points(i,1))
  R(i) = fx - points(i,2)
  rss = rss + R(i)**2
  ! Add difference to each parameter to find deriv wrt each parameter
  Do k=1,size(parameters,1)
    finite_difference = abs(parameters_perturbed(k) * difference_factor)
    If (finite_difference .EQ. 0.0D0) Then
      finite_difference = 1.0D-9
    End If
    parameters_perturbed = parameters
    parameters_perturbed(k) = parameters(k) + finite_difference
    fxP = LMA_F(F, parameters_perturbed, points(i,1))
    J(i,k) = (fxP-fx)/finite_difference
  End Do
End Do
END SUBROUTINE LMA_Make_J


SUBROUTINE LMA_Loop(F, parameters, points, limits, weighting, J, R, rss, lambda, &
lambdaCutoff, p_conv_threshold, p_conv_value, runloop)
IMPLICIT NONE
INTEGER :: F
REAL(8), INTENT(INOUT), Dimension(:) :: parameters
REAL(8), Dimension(:,:) :: points
REAL(8), Dimension(:,:) :: limits
LOGICAL :: weighting
REAL(8), Dimension(:,:) :: J
REAL(8), Dimension(:) :: R
REAL(8) :: rss
REAL(8) :: lambda, lambdaCutoff
REAL(8) :: p_conv_threshold
REAL(8) :: p_conv_value
LOGICAL, INTENT(OUT) :: runloop

! Vars:  Private variables
REAL(8), Dimension(1:size(parameters,1)) :: parameters_last
REAL(8) :: rssTrial
LOGICAL :: converged
! Delayed gratification scheme
runloop = .True.
! Store last set of parameters
parameters_last = parameters
! calculate new parameters
parameters = LMA_Calc(J,R,lambda,lambdaCutoff,parameters,limits, weighting)

! Check parameter convergence
p_conv_value = LMA_ParameterConvergence(parameters, parameters_last)

! Calc RSS
rssTrial = LMA_FUNCTION_RSS(F, points, parameters)
! Breakout if NaN
If (Isnan(rssTrial)) Then
  runloop = .False.
  parameters = parameters_last
Else
  If(p_conv_value .LT. p_conv_threshold)Then
    runloop = .False.
  ! Delayed gratification scheme - 1.5*lambda or 0.2*lambda
  Else
    If(rssTrial.gt.rss)Then  ! If worse
      If(lambda.lt.lambdaCutoff)Then
        lambda = 2.0D0*lambdaCutoff
      End If
      lambda = lambda * 1.5D0
      parameters = parameters_last
    Else  ! If better
      lambda = lambda * 0.2D0
      runloop = .False.
    End If
  End If
End If
END SUBROUTINE LMA_Loop


FUNCTION LMA_ParameterConvergence(p_old, p_new) RESULT (convergence)
REAL(8), Dimension(:) :: p_old
REAL(8), Dimension(:) :: p_new
REAL(8) :: convergence
INTEGER :: n
convergence = 0.0D0
Do n = 1, size(p_old, 1)
  convergence = convergence + abs(p_old(n) - p_new(n))
End Do
convergence = convergence / n
END FUNCTION LMA_ParameterConvergence

FUNCTION LMA_Calc(J,R,lambda,lambdaCutoff, parametersIn,limits,weighting) RESULT (parametersOut)
IMPLICIT NONE  !Force declaration of all variables
! In
REAL(8), Dimension(:,:) :: J                                     ! Jacobian
REAL(8), Dimension(:) :: R                                       ! Residuals
REAL(8), Dimension(:) :: parametersIn
REAL(8), Dimension(:,:) :: limits
REAL(8) :: lambda
REAL(8) :: lambdaCutoff
LOGICAL :: weighting
! Out
REAL(8), Dimension(1:size(parametersIn,1)) :: parametersOut
! Private variables
INTEGER :: i
REAL(8), Dimension(1:size(R),1:size(R)) :: W                !
REAL(8), Dimension(1:size(J,2),1:size(J,1)) :: JT               ! Transpose Jacobian
REAL(8), Dimension(1:size(J,2),1:size(J,1)) :: JTW              !
REAL(8), Dimension(1:size(J,2),1:size(J,2)) :: JTWJ
REAL(8), Dimension(1:size(J,2),1:size(J,2)) :: JTWJ_Diag
REAL(8), Dimension(1:size(J,2)) :: JTWR
REAL(8), Dimension(1:size(J,2),1:size(J,2)) :: A  ! Left side
REAL(8), Dimension(1:size(J,2)) :: B              ! Right side
REAL(8), Dimension(1:size(J,2)) :: P                             ! Change
LOGICAL :: weighting_default
! ***********
! P = (JTJ+Lambda*diag(JTJ))^(-1)(-1*JTR)
! (JTJ+Lambda*diag(JTJ)) P = (-1*JTR)
! ***********
! Check Marquardt parameter cutoff
! Check Marquardt parameter cutoff
If(lambda.lt.lambdaCutoff)Then
  lambda = 0.0D0
End If
! Prep covariance matrix
W = 0.0D0
If (weighting)Then
  weighting_default = .False.
  Do i = 1, size(R)
    If (R(i) .LT. 1.0D-50) Then
      weighting_default = .True.
      Exit
    End If
  End Do
  ! Use default weighting matrix as R it becoming too small
  If (weighting_default) Then
    Do i=1,size(R)
      W(i,i) = 1.0D99
    End Do
  ! Use calculated weighting
  Else
    Do i=1,size(R)
      W(i,i) = 1.0D0/R(i)**2
    End Do
  End If
Else
  ! No weighting
  Do i=1,size(R)
    W(i,i) = 1.0D0
  End Do
End If

! Matrix calculations
JT = Transpose(J)     ! matrix.f90
JTW = matmul(JT,W)
JTWJ = matmul(JTW,J)
JTWR = matmul(JTW,R)
JTWJ_Diag = lambda*DiagMatrix(JTWJ) ! Dampening Matrix
A = MatAdd(JTWJ,JTWJ_Diag)
B = -1.0D0*JTWR
P = lss(A, B)

! Update parameters
Do i=1,size(P)
  If (limits(i,1) .LE. limits(i,2)) Then
    parametersOut(i) = parametersIn(i) + P(i)
    If (limits(i,1) .LT. limits(i,2)) Then
      If(parametersOut(i) .LT. limits(i,1))Then
        parametersOut(i) = limits(i,1)
      Else If(parametersOut(i) .GT. limits(i,2))Then
        parametersOut(i) = limits(i,2)
      End If
    End If
  End If
End Do
END FUNCTION LMA_Calc


FUNCTION LMA_Lambda(J) RESULT (lambda)
IMPLICIT NONE  !Force declaration of all variables
! In
REAL(8), Dimension(:,:) :: J                                     ! Jacobian
! Out
REAL(8) :: lambda
! Private variables
REAL(8), Dimension(1:size(J,2),1:size(J,1)) :: JT                ! Transpose Jacobian
REAL(8), Dimension(1:size(J,2),1:size(J,2)) :: JTJ, JTJ_Inv
REAL(8) :: traceJTJ
! Calculate starting lambda/lambda cutoff
JT = Transpose(J)
JTJ = matmul(JT,J)
JTJ_Inv = InvertMatrix(JTJ)
! Check Marquardt parameter cutoff
traceJTJ = Trace(JTJ_Inv)
lambda = traceJTJ**(-1)
END FUNCTION LMA_Lambda


FUNCTION LMA_FUNCTION_RSS(F, points, parameters) RESULT (rss)
! RSS between function and calculated points
IMPLICIT NONE
! Vars:  In
INTEGER :: F
REAL(8), Dimension(:,:) :: points
REAL(8), Dimension(:) :: parameters
! Out
REAL(8) :: rss
! Private variables
REAL(8) :: x, y, fx
INTEGER :: i
! RSS
rss = 0.0D0
Do i=1,size(points,1)
  x = points(i,1)
  y = points(i,2)
  fx = LMA_F(F, parameters, x)
  rss = rss + (y - fx)**2
End Do
END FUNCTION LMA_FUNCTION_RSS


FUNCTION LMA_F(F, parameters, x) RESULT (y)
IMPLICIT NONE
INTEGER :: F
REAL(8), DIMENSION(:) :: parameters
REAL(8) :: x
REAL(8) :: y
y = F_Function(F, parameters, x)
END FUNCTION LMA_F

\end{lstlisting}


